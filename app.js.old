(function($) {
	var width = $('#container').width();
	var height = $('#container').height();
	var paper = Raphael(document.getElementById('container'), width, height);

	var BrickSide = 20;
	var Brick = function(o) {

			this.y = o.y;
			this.x = o.x;
			this.ele = paper.rect(this.x, this.y, BrickSide, BrickSide, 2, 2);
			this.ele.attr({
				fill: o.color
			});
			return this.ele;
		}
	var Block = function() {
			this.color = randomColor();
			this.y = -60;
			this.x = width / 2;
			this.angle = 90 * random(1, 4);
			this.type = random(1, 7);
			this.draw = function() {

				if (this.bricks) this.bricks.remove();
				this.bricks = paper.set();
				this.bricks.attr({
					'stroke-linecap': 'round',
					'stroke-width': 2
				})
				switch (this.type) {
				case 1:
					// 2X2
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y + BrickSide
					}));
					break;
				case 2:
					// 4x1
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide * 2
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide * 3
					}));
					break;
				case 3:
					// L
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide * 2
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y
					}));
					break;
				case 4:
					// J
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide * 2
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x - BrickSide,
						y: this.y
					}));
					break;
				case 5:
					// S
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y + BrickSide
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y + BrickSide
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide * 2,
						y: this.y
					}));
					break;
				case 6:
					// Z
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y + BrickSide
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide * 2,
						y: this.y + BrickSide
					}));
					break;
				case 7:
					// W
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide * 2,
						y: this.y
					}));
					this.bricks.push(new Brick({
						color: this.color,
						x: this.x + BrickSide,
						y: this.y + BrickSide
					}));
					break;
				default:

					break;
				};
				this.bb = this.bricks.getBBox(false);
				var w = this.bb.width / 2;
				var h = this.bb.height / 2;
				if (w % 20 == 10) w = w - 10;
				if (h % 20 == 10) h = h - 10;
				if (w % 10 == 5) w = w - 5;
				if (h % 10 == 5) h = h - 5;
				var tStr = "r" + this.angle + "," + (this.bb.x + w) + "," + (this.bb.y + h);
				this.bricks.transform(tStr)
				this.bricks.transform();
			}

			this.draw();

		}
	var speed = 300;
	var EVENTS = {};
	var block = new Block();
	var lastUpdate = 0;
	var last = 0;
	var blocks = new Array();
	blocks.length = 0;
	var loop = function() {

			var now = Date.now();
			var elapsed = (now - lastUpdate);
			var elapsed2 = (now - last);
			if (elapsed >= 60000) {
				lastUpdate = now;
				speed -= 50;
			}
			if (elapsed2 >= speed) {
				last = now;
				block.y += BrickSide;
				block.draw();
			}


			var collision = false;
			if (blocks.length > 0) $.each(blocks, function(i, b) {
				$.each(b.bricks, function(i, br) {
					$.each(block.bricks, function(i, me) {
						var bb1 = br.getBBox();
						var bb2 = me.getBBox();
						//if (Raphael.isBBoxIntersect(me.getBBox(true), br.getBBox(true))) {
						if (br.attr('opacity') != 0) if (bb1.x == bb2.x && bb1.y == bb2.y2) {
							collision = true;
						}
					})
				})
			});
			if (block.bricks.getBBox(false).y2 >= height - 10) collision = true;
			if (!collision) {
				handler();
				block.draw();
				$.each(blocks, function(i, b) {
					$.each(b.bricks, function(i, br) {
						$.each(block.bricks, function(i, me) {
							var bb1 = br.getBBox();
							var bb2 = me.getBBox();
							if (br.attr('opacity') != 0) {
								if (bb1.x == bb2.x && bb1.y == bb2.y2) {
									collision = true;
								}
								if (bb2.x <= 0 - BrickSide + 1 || bb2.x2 >= width + BrickSide - 1) {
									collision = true;
								}
							}
						})
					})
				});
				if (blocks.length == 0) {
					$.each(block.bricks, function(i, me) {
						var bb2 = me.getBBox();
						if (bb2.x <= 0 - BrickSide + 1 || bb2.x2 >= width + BrickSide - 1) {
							collision = true;
						}
					})
				}
				if (block.bricks.getBBox(false).y2 >= height - 10) collision = true;
				if (collision) {
					if (EVENTS.ROTATE) {
						block.angle -= 90;
					}
					if (EVENTS.LEFT) {
						block.x += BrickSide;
					}
					if (EVENTS.RIGHT) {
						block.x -= BrickSide;
					}
					if (EVENTS.DOWN) {
						block.y -= BrickSide;
					}
					block.draw();
				}
				EVENTS = {};
			} else {
				blocks.push(block);
				// check for full lines
				for (var y = 10; y < height; y = y + 20) {
					var line = true;
					for (var x = 10; x < width; x = x + 20) {
						var yep = false;
						$.each(blocks, function(i, b) {
							$.each(b.bricks, function(i, br) {
								var bb = br.getBBox();
								if (br.attr('opacity') != 0) if (bb.x < x && bb.x2 > x && bb.y < y && bb.y2 > y) {
									yep = true;
								}
							});
						});
						if (!yep) {
							line = false;
							break;
						}
					}
					if (line) {
						for (var x = 10; x < width; x = x + 20) {
							var yep = false;
							$.each(blocks, function(i, b) {
								$.each(b.bricks, function(i, br) {
									var bb = br.getBBox();
									if (bb.x < x && bb.x2 > x && bb.y < y && bb.y2 > y) {
										br.attr({
											opacity: 0
										});
									}
								});
							});
						}
						for (var yy = y-20; yy > 0; yy = yy - 20) {
							for (var x = 10; x < width; x = x + 20) {
								$.each(blocks, function(i, b) {
									$.each(b.bricks, function(i, br) {
										var bb = br.getBBox();
										if (bb.x < x && bb.x2 > x && bb.y < yy && bb.y2 > yy) {
											br.transform("...T0,"+BrickSide);
										}
										});
									});
							}
						}
					}
				}
				$.each(blocks, function(i, b) {
					$.each(b.bricks, function(i, br) {
						var bb = br.getBBox();
						if (br.attr('opacity') != 0) if (bb.y < 0) {
							clearInterval(gameLoop);
							alert('game over!');
						}
					});
				});
				block = new Block();
			}

		}

	var KEYS = {
		W: 87,
		A: 65,
		S: 83,
		D: 68,
		LEFT: 37,
		UP: 38,
		RIGHT: 39,
		DOWN: 40
	};
	$(window).bind('keydown', function(e) {
		switch (e.which) {
		case KEYS.W:
		case KEYS.UP:
			EVENTS.ROTATE = true
			break;
		case KEYS.A:
		case KEYS.LEFT:
			EVENTS.LEFT = true;
			break;
		case KEYS.S:
		case KEYS.DOWN:
			EVENTS.DOWN = true;
			break;
		case KEYS.D:
		case KEYS.RIGHT:
			EVENTS.RIGHT = true;
			break;
		default:

			break;
		};

	});
	$('#content').hammer({
		prevent_default: true,
		drag_vertical: false,
		swipe_time         : 800,   // ms
        		swipe_min_distance : 5// pixels
	}).bind("tap swipe", function(ev) {
		if (ev.type == 'swipe') {
			EVENTS.LEFT = ev.direction == 'left';
			EVENTS.RIGHT = ev.direction == 'right';
			EVENTS.ROTATE = ev.direction == 'up';
			EVENTS.DOWN = ev.direction == 'down';
		}
		if (ev.type == 'tap') {
			EVENTS.ROTATE = true
		}

	});

	function handler() {

		if (EVENTS.ROTATE) {
			block.angle += 90;
		}
		if (EVENTS.LEFT) {
			block.x -= BrickSide;
		}
		if (EVENTS.DOWN) {
			block.y += BrickSide;
		}
		if (EVENTS.RIGHT) {
			block.x += BrickSide;
		}
	}
	var gameLoop = setInterval(loop, 50);

})(jQuery);